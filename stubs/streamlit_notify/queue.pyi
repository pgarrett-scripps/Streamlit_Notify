from typing import Iterable

from _typeshed import Incomplete

from .dclass import StatusElementNotification as StatusElementNotification

class NotificationQueue:
    queue_name: Incomplete
    def __init__(self, queue_name: str) -> None: ...
    @property
    def queue(self) -> list[StatusElementNotification]: ...
    def has_items(self) -> bool: ...
    def is_empty(self) -> bool: ...
    def append(self, item: StatusElementNotification) -> None: ...
    def extend(self, items: Iterable[StatusElementNotification]) -> None: ...
    def remove(self, item: StatusElementNotification | int) -> None: ...
    def contains(self, item: StatusElementNotification) -> bool: ...
    def get_all(self) -> list[StatusElementNotification]: ...
    def clear(self) -> None: ...
    def pop(self, index: int = 0) -> StatusElementNotification | None: ...
    def get(self, index: int = 0) -> StatusElementNotification | None: ...
    def size(self) -> int: ...
    def __len__(self) -> int: ...
    def __bool__(self) -> bool: ...
    def __contains__(self, item: StatusElementNotification) -> bool: ...
    def __getitem__(self, index: int) -> StatusElementNotification: ...
    def __setitem__(self, index: int, value: StatusElementNotification) -> None: ...
    def __delitem__(self, index: int) -> None: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __iter__(self) -> Iterable[StatusElementNotification]: ...
    def __reversed__(self) -> Iterable[StatusElementNotification]: ...
    def __copy__(self): ...
    def __deepcopy__(self, memo: dict[int, object]): ...
